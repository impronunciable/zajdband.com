<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sobre las cartas la mesa</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <article class="container">
        <header>
            <h1>Sobre las cartas la mesa</h1>
            <h2>(Intentando) entender lo que quieren decir nuestros usuarios</h2>
        </header>
        <section>
            <h3>Estructura y automatizaci√≥n</h3>
            <blockquote>Si quer√©s consistencia necesit√°s un sistema hecho por un solo programador</blockquote>
            <p>
                Cuando trabajamos en sistemas inform√°ticos nos resulta indispensable contar con informaci√≥n estructurada.
                Esto nos permite organizar, analizar y distribuir informaci√≥n de una forma predecible, haciendo la vida de nos,
                los programadorxs mucho m√°s fel√≠z, simplificando tambi√©n el modelo mental del problema que estamos resolviendo
                y haciendo m√°s eficiente la carga y el guardado de los datos.
            </p>
            <p>
                Contar con datos estructurados nos permite enfocarnos en la complejidad interna de nuestro sistema, sacandonos de encima
                uno de los problemas m√°s manuales y tediosos de nuestro rubro, la limpieza de datos. En otras palabras, estructurar es <strike>poblar</strike> automatizar.
                Si no te convence lo que digo intent√° scrappear un sitio de noticias y volv√©.
            </p>
            <p class="caption">
                <img src="images/table.gif" alt="tabla">
                Estructurar nuestros datos nos ayuda a crear software m√°s eficiente, predecible y robusto.
            </p>
        </section>            
        <section>
            <h3>Que vagancia la de Francia</h3>
            <blockquote>Las interfaces de usuarios se reducen en un 90% a formularios y listas</blockquote>
            <p>
                Como queremos contar con informaci√≥n estructurada desde el primer momento, solemos someter a nuestros usuarios a
                utilizar una serie de componentes que cuentan con una cantidad definida de opciones para que se limiten a elegir
                una y solo una de las que los dioses creadores de este software planificaron para su experiencia.
            </p>
            <p class="caption">
                <img src="images/afip.jpg" alt="formulario">
                A veces se nos va la mano con la estructura.
            </p>
            <p>
                La otra cara de la sobre-estructura de los formularios son las validaciones de input a posteriori.
                En este caso al pobre usuario lo dejamos escribir lo que quiera en un campo libre, solamente para demostrarle
                al final que no fue digno de la libertad que le dimos, que cometi√≥ un error fatal y que debe volver a rehacer su tarea.
                De hecho utilizamos el color rojo, haciendo alusi√≥n a la bic con la que la maestra ciruela nos mandaba a revisar las burradas.
            </p>
            <p class="caption">
                <img src="images/email.png" alt="email regexp">
                Una expresi√≥n regular para emails que funciona el 99.99% de las veces.
            </p>    
            <p>
                Con formularios sobreestructurados y con validaciones superfuertes la vida nos sonr√≠e. Ya nunca m√°s tendremos que preocuparnos por los malditos
                usuarios, sus typos y nombres complicados <em>muejejejejeje</em> (risa mal√©vola). 
            </p>
            <p>
                La pregunta que nos hacemos entonces es, <strong>C√≥mo podemos liberar a nuestros usuarios de la tiran√≠a de la estructura y comernos el garr√≥n nosotros?</strong>
            </p>
        </section>
        <section>
            <h3>Otroletravaladna</h3>
            <blockquote>Obv√±zfhnhxds</blockquote>
            <p>
                Ahora que te convenc√≠ de que somos entes mal√©volos que solo queremos darle trabajo innecesario a los pobres mortales, inundandolos en un mar de burocrac√≠a web√≠stica,
                vengo a pararme de la otra vereda. Entender a la gente es dif√≠cil.
            </p>
            <p>
                La mayor√≠a de los m√©todos de NLP (Procesamiento del lenguaje natural) tradicionales, utilizan la estructura del lenguaje para intepretarlo y pasar de informaci√≥n no estructurada
                o coloquial a algo que podamos masticar con nuestras mandibulas de silicio.
                Adem√°s, m√©todos efectivos de NLP suelen requerir conocimientos en Machine Learning y la gran cantidad de corpus solo est√°n preparados para angloparlantes, <strong>buuuuuuerns!</strong>.
            </p>
            <p>
                Como si esto fuera poco, en la era del tel√©fono celular distamos mucho de lo que estos sistemas esperan. Los c√≥digos
                que se manejan en el <strike>sexting</strike> texting son distintos a los que encontramos en la mayor√≠a de los corups etiquetados.

            </p>
            <p class="caption">
                <img src="images/atendedor.jpg" alt="atendedor">
                Vericuetos del lenguaje.
            </p>
            <p>
                Por suerte para nosotros, hay algunos truquitos que podemos usar para exigirle menos robotizaci√≥n a los usuarios sin perder la oportunidad
                de ver maratones de series estupidizantes en Netflix.
            </p>
        </section>
        <section>
            <h3>Doctor reformulemelo</h3>
            <blockquote>Partido por partido, paso a paso</blockquote>
            <p>
                En esta b√∫squeda por hacer formularios menos alienantes, esquivandole tambi√©n a la necesidad de aprender t√©cnicas de programaci√≥n para gente
                m√°s inteligente que yo, descubr√≠ que hay un truquito muy interesante (patada baja, pi√±a alta, abajo, abajo, adelante, klapaucius).
                En general, nuestros formularios estructurados poseen un dominio muy acotado, simplemente identificando palabras clave o patrones simples podemos
                agarrar la esencia de lo que la persona del otro lado nos quiere transmitir y as√≠ nosotros hacer el trabajo de traducir esa informaci√≥n no estructurada
                en algo que nuestra base de datos puede digerir sin un hepatalgina.
            </p>
            <p class="caption">
                <img src="images/guri.jpeg" alt="GuriVR">
                GuriVR.com te deja (ponele) escribir en lenguaje natural y crear escenas de realidad virtual.
            </p>
            <p>
                La t√©cnica m√°s simple y efectiva que tenemos a mano es pensar como un usuario y crear peque√±as reglas usando expresiones regulares.
                Si el texto que recibimos cumple con una regla, tomamos ese input y lo estructuramos.

                En 2016, trabajando en un proyecto de formularios en periodismo para el <a href="https://coralproject.net">Coral Project</a>, hice
                un experimento para intentar entender el mejor componente de formulario para una pregunta, basado en el t√≠tulo de la pregunta.
            </p>
            <iframe src="https://impronunciable.github.io/askme/"></iframe>
            <p>
                Si van al <a href="https://github.com/impronunciable/askme/blob/master/src/services/inferQuestionType.js">c√≥digo del experimento</a> van a entender
                como pude implementar esta mejora mientras conservo mis u√±as impecables (?). Ante cada pregunta ingresada por el usuario,
                chequeo algunos patrones super simples y decido que tipo de widget usar en caso de match.
            </p>
            <p class="caption">
                <img src="images/preguntas.png" alt="Preguntas">
                60% of the time it works every time.
            </p>    
        </section>
        <section>
            <h3>Helader√≠a "La doble Visera"</h3>
            <blockquote>Suena como suena, suena como otra canci√≥n, y ella se derrite como helado pero de lim√≥n</blockquote>
            <p>
                Para ejemplificar vamos a suponer que somos m√°s sortudos como el gato de Alf y nos ponemos una helader√≠a y somos tan
                copados que vamos a dejarle a la gente escribir lo que le pinte y tratar de entender con que van a deleitarse.
                Lo primero que vamos a hacer es determinar que t√©rminos nos interesan.
                Por un lado queremos entender cantidades y por otro gustos.
            </p>
            <div>
                <p><strong>Las cantidades:</strong></p>
                <ul>
                    <li>(1/4, 1/2, 1, 2, 3... 10) kilos</li>
                    <li>Cucurucho</li>
                    <li>Vasito</li>
                </ul>

                <p><strong>Los gustos:</strong></p>
                <ul>
                    <li>Vainilla</li>
                    <li>Americana</li>
                    <li>Frutilla</li>
                    <li>Lim√≥n</li>
                    <li>Dulce de leche granizado</li>
                    <li>Banana split</li>
                </ul>
            </div>
            <p class="small">
                <strong>Disclaimer:</strong> La t√©cnica que vamos a usar a continuaci√≥n no es la m√°s limpia ni profesional que existe.
                Lo que queremos mostrar es que poniendo reglas super simples podemos "agarrar" lo que queremos en muchos casos.
            </p>
            
            <h4>Interpretando las medidas:</h4>
            <p>
                Para interpretar las medidas vamos a poner un par de reglas muy sencillas usando expresiones regulares.
                Si leemos 1/4, 1/2 o un d√≠gito cualquiera (menos el 0) y luego un espacio y la palabra kilo, con un "de " en el medio, entonces
                sabemos que se quiere esa medida de kilos. La expresi√≥n regular escrita en JavaScript que lo representa podr√≠a ser algo como:                
            </p>
            <p class="snippet"> /(un|dos|tres|1\/4|1\/2|[1-9])( de)? ((k|qu)ilo|cucurucho|vasito)s?/gi</p>
            <p>
                De hecho ah√≠ somos tan comprensivos que si alg√∫n brutus escribe "quilo" est√° todo buey.
            </p>
            <textarea id="kilos" placeholder="Prob√° a ver si lo agarramos"></textarea>
            <p id="kilos-result"></p>
            <p>
                Para obtener todas las medidas y extraer cuanto de cada una uso el siguiente cachito de c√≥digo (siempre y cuando "kilosreg" sea la expresi√≥n regular):
            </p>
            <pre><p class="snippet">
if (kilosreg.test(txt)) {
    kilosreg.lastIndex = 0
    var results = []
    var res = kilosreg.exec(txt)
    while (res != null) {
        res[1] = res[1].replace('un', '1')
            .replace('dos', '2')
            .replace('tres', '3')
        results.push(res)
        res = kilosreg.exec(txt)
    }               
    // ac√° results tiene la posta de medidas
}
</p></pre>
            
            <h4>Agarrandole el gustito:</h4>
            <p>
                Vamos a limitarnos a los gustos que elegimos. Lo bueno de usar expresiones regulares y un if/else largo en vez de matches
                especificos con strings es que nos permite agregar casos interesantes como el de (kilo y quilo) sin volvernos locos.
                Estas funciones corren en microsegundos, no te preocupes en optimizar hasta que sea un problema.
                En este caso vamos a agarrar los gustos que podamos e incluso agarrar algunos famosos que no tenemos para avisar. Incluso vamos a bancarnos
                que vengan extranjeros a hacernos los pedidos üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø .
                Todo esto viene incluido en este fant√°stico y horror√≠fico if que ser√≠a bochado en muchas entrevistas t√©cnicas, demostrando pero amada por los
                clientes, que es lo que importa. 
            </p>
            <pre><p class="snippet">
var results = []
if (/vai?nilla/i.test(txt)) {
    results.push('vainilla')
}
if (/(crema )?americana|cream/i.test(txt)) {
    results.push('americana')
}
if (/frutilla|strawberry|üçì/i.test(txt)) {
    results.push('frutilla')
}
if (/limon|lemon|lim√≥n|üçã/i.test(txt)) {
    results.push('lim√≥n')
}
if (/(dulce de leche|ddl) granizado/i.test(txt)) {
    results.push('dulce de leche granizado')
}
if (/banana split|üçå/i.test(txt)) {
    results.push('banana split')
}
if (/pera|pear|üçê/i.test(txt)) {
    results.push('pera')
}
if (/durazno|peach|üçë/i.test(txt)) {
    results.push('pera')
}
            </p></pre>
            <textarea id="gustos" placeholder="A ver esos gustitos"></textarea>
            <p id="gustos-result"></p>

            <h4>El ba√±o de chocolate:</h4>
            <p>
                Vamos a juntar ambas cosas para entender un pedido entero. El truco ac√° es dividir el texto cada vez que nos hablan de una medida.
                Cada vez que se menciona una medida, creemos que nos hablan de gustos hasta que pasen a la siguiente medida. Esto lo hacemos
                guardanonos los √≠ndices donde aparecen las medidas en el texto y partiendolo para correr las expresiones regulares de gustos en cada caso:            
            </p>
            <pre><p class="snippet">
document.querySelector('#mix').addEventListener('keyup', function(e) {
    var txt = this.value
    var orders = getOrders(txt)
    var out = orders.map((order, i) => {
        var end = txt.length - 1
        if (i < orders.length - 1) {
            end = orders[i+1].index
        }
        var flavors = getFlavors(txt.substring(order.index, end + 1))
        return order[3] + ' (' + order[1] + '): ' + flavors.join(', ')
    })
    document.querySelector('#mix-result').textContent = out.join(' ‚Ä¢ ')
})            
            </p></pre>
            <textarea id="mix" placeholder="Prob√° a ver si anda todo junto"></textarea>
            <p id="mix-result"></p>
        </section>
        <section>
            <h3>Pap√° cuentame otra vez</h3>
            <blockquote>que importa que importa el blablabl√°</blockquote>
            <p class="small">
                    <strong>Disclaimer:</strong> Lo siguiente anda (creo) solo en Chrome y amigos.
                </p>    
            <p>
                Para terminar vamos a dar un pasito m√°s y pensar en la prima mala que manda audios de WhatsApp. Ella es claramente nuestra usuaria
                tipo para la helader√≠a. Vamos a dejarla afuera? Pero claro que no. Por eso vamos a usar la hermosa API de Speech recognition
                para dejar a la prima dele que blablabla mientras nosotros facturamos.
            </p>
            <p>
                Para lograr esto simplemente vamos a agregar un bot√≥n para que la persona grabe un mensaje de voz. Una vez que obtenemos texto,
                lo analizamos como haciamos antes con el textarea:
            </p>
            <pre><p class="snippet">
var speaking = false
var SpeechRecognition = window.SpeechRecognition
var recognition = new SpeechRecognition()
recognition.lang = 'es-AR'
document.querySelector('#recognition').addEventListener('click', function(){
    if (speaking) {
        speaking = false
        recognition.stop()
        return
    }
    recognition.onresult = event => {
        var speechToText = event.results[0][0].transcript
        var res = document.querySelector('#recognition-result')
        res.textContent = analyzeOrders(speechToText)
    }
    recognition.start()
    speaking = true
})            
            </p></pre>
            <p>
                <button id="recognition">Empezar/pausar</button>
                <p id="recognition-result"></p>
            </p>
        </section>
        <section>
            <p>
                Esto fue: Como chamuyar que sabemos programar y poner contentos a nuestros usuarios para Nintendo64. Espero que les haya gustado. Chau.
            </p>
        </section>
    </article>
    <script>
        var kilosreg = /(un|dos|tres|1\/4|1\/2|[1-9])( de)? ((k|qu)ilo|cucurucho|vasito)s?/gi
        function getOrders(txt) {
            var results = []
            var res = kilosreg.exec(txt)
            while (res != null) {
                res[1] = res[1].replace('un', '1').replace('dos', '2').replace('tres', '3')
                results.push(res)
                res = kilosreg.exec(txt)
            } 
            return results
        }

        function getFlavors(txt) {
            var results = []
            if (/vai?nilla/i.test(txt)) {
                results.push('vainilla')
            }
            if (/(crema )?americana|cream/i.test(txt)) {
                results.push('americana')
            }
            if (/frutilla|strawberry|üçì/i.test(txt)) {
                results.push('frutilla')
            }
            if (/limon|lemon|lim√≥n|üçã/i.test(txt)) {
                results.push('lim√≥n')
            }
            if (/(dulce de leche|ddl) granizado/i.test(txt)) {
                results.push('dulce de leche granizado')
            }
            if (/banana split|üçå/i.test(txt)) {
                results.push('banana split')
            }
            if (/pera|pear|üçê/i.test(txt)) {
                results.push('pera')
            }
            if (/durazno|peach|üçë/i.test(txt)) {
                results.push('pera')
            }
            return results
        }

        function analyzeOrders(txt) {
            var orders = getOrders(txt)
            return orders.map((order, i) => {
                var end = txt.length - 1
                if (i < orders.length - 1) {
                    end = orders[i+1].index
                }
                var flavors = getFlavors(txt.substring(order.index, end + 1))
                return order[3] + ' (' + order[1] + '): ' + flavors.join(', ')
            }).join(' ‚Ä¢ ')
        }
        
        document.querySelector('#kilos').addEventListener('keyup', function(e) {
            var txt = this.value
            if (kilosreg.test(txt)) {
                kilosreg.lastIndex = 0
                var results = getOrders(txt)
                document.querySelector('#kilos-result').textContent = results.map(res => res[3] + ': ' + res[1]).join(' - ')
            }
        })

        document.querySelector('#gustos').addEventListener('keyup', function(e) {
            var txt = this.value    
            document.querySelector('#gustos-result').textContent = getFlavors(txt).join(' - ')
        })

        document.querySelector('#mix').addEventListener('keyup', function(e) {
            document.querySelector('#mix-result').textContent = analyzeOrders(this.value)
        })

        var speaking = false
        var SpeechRecognition = window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition
        var recognition = new SpeechRecognition()
        recognition.lang = 'es-AR'
        document.querySelector('#recognition').addEventListener('click', function(){
            if (speaking) {
                speaking = false
                recognition.stop()
                return
            }
            recognition.onresult = event => {
                var speechToText = event.results[0][0].transcript
                document.querySelector('#recognition-result').textContent = analyzeOrders(speechToText)
            }
            recognition.start()
            speaking = true
        })
    </script>
</body>
</html>