{"componentChunkName":"component---src-templates-post-template-js","path":"/universal-rendering-with-preact/","result":{"data":{"markdownRemark":{"id":"07693109-8693-59c7-8336-e07fde43dd88","html":"<p>As <a href=\"https://twitter.com/rauchg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@rauchg</a> stated, <a href=\"https://rauchg.com/2014/7-principles-of-rich-web-applications/#server-rendered-pages-are-not-optional\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">server renderer pages are not optional</a>. On my journey redoing the <a href=\"https://hackdash.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HackDash</a> front-end I’m trying to apply best practices on this software piece, so implementing Universal rendering was one of the first challenges.</p>\n<p>In this article I explain a technique and conventions to follow in order to achieve Universal rendering (the ability to render an app both client and server side) using <a href=\"https://preactjs.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">preact</a>, node and <a href=\"https://redux.js.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">redux</a>. This is not the only way to do it but it can help you understand some concepts behind this technique. You can see a demo of the Work in Progress using <a href=\"https://zeit.co/now\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">now</a> for the deployment <a href=\"https://hackdash-front-pgalvabhlc.now.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>, the code is <a href=\"https://github.com/impronunciable/hackdash-front\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Open-Source</a>.</p>\n<p><strong>TL;DR</strong></p>\n<p>An easy way to develop this kind of single-page apps with universal rendering is to break your app in pages (in my case each page refer <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/src/components/App.js#L13\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">1-on-1 with a route</a>) and provide an initial fetch redux action for each page. Then, on the server, <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/server.js#L25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">provide a middleware</a> to fetch that data and when you get the redux action that indicates the data is loaded, <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/template.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">render the page</a> along with a JSON representation of the initial state of the app.</p>\n<p><strong>Transpile your server-side code (too)</strong></p>\n<p>Because we want to render our client-side preact app on the server, importing the client code into the server, we need to transpile our node code too. Webpack allows to specify a <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/webpack.config.back.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">node target</a> that deals for this specific environment while helping with, for example, the jsx components.</p>\n<p><strong>Avoid the usage of browser specific variables</strong></p>\n<p>Using browser-only variables like <em>window</em> and <em>document</em> will break your server builds. If you must use them you can access to <a href=\"https://github.com/Raynos/global\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">global polyfills</a> or declare them as external on your webpack configuration.</p>\n<p><strong>Share as much code as you can</strong></p>\n<p>The only difference between the code executed in the server and the client is a <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/server.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">minimal express app</a>. This code is in charge of fetching the initial data for the required page (using the same redux store as the front-end) and render the initial HTML document. Is important to notice the 1-on-1 mapping between the <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/src/components/App.js#L13\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">client</a> and the server <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/server.js#L39\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">routes</a>.</p>\n<p><strong>Identify each page first render data</strong></p>\n<p>This may be the hardest part of this technique. There should be one entry point for each page. This doesn’t mean that you can do only one request for a page, you only need to identify when the first render data is loaded and dispatch a <em>SERVER</em>READY _action. This will allow the middleware to know when to render your app. The way I prevent the first data to be fetched again on the client is just with <a href=\"https://github.com/impronunciable/hackdash-front/blob/master/src/actions.js#L7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a boolean</a> indicating if the app was already mounted once.</p>\n<p><strong>More to come</strong></p>\n<p>As I said, this is just a WIP. This is the first of a serie of follow-ups on the development of the app. You can follow me on twitter as <a href=\"https://twitter.com/impronunciable\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@impronunciable</a>.</p>\n<p> </p>","fields":{"slug":"/universal-rendering-with-preact/","tagSlugs":["/tag/hack-dash/","/tag/node-js/","/tag/opennews/"]},"frontmatter":{"date":"2016-05-10T01:26:06.000Z","description":"In this article I explain a technique and conventions to follow in order to achieve Universal rendering (the ability to render an app both client and server side) using preact, node and redux.","tags":["HackDash","node.js","opennews"],"title":"Universal rendering with preact","socialImage":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/universal-rendering-with-preact/"}}}